#!/usr/bin/env python3
"""
Test script for 0x69 vanity address generation and CREATE2 calculation
This validates the entire flow before implementing in the main deployer
"""

import asyncio
import aiohttp
import json
from web3 import Web3
from eth_utils import to_checksum_address
from Crypto.Hash import keccak
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class VanityAddressTest:
    def __init__(self):
        # Use the same factory address as the real deployer (corrected to match API)
        self.factory_address = "0xa44bb5b4A4D8db99F1F92e00BB34EF759042ccCE"
        self.deployer_address = "0xb3Bc6906F91181122F6499A32A0D04390ec87273"
        
        # Initialize Web3 for calculations
        self.w3 = Web3()
        
    async def test_salt_generation(self, token_name: str, token_symbol: str):
        """Test salt generation from Klik Finance API"""
        print(f"🎲 Testing vanity salt generation for {token_name} ({token_symbol})...")
        
        try:
            # Call Klik Finance API to generate salt
            url = f"https://klik.finance/api/generate-salt"
            params = {
                'name': token_name,
                'symbol': token_symbol,
                'creator': self.deployer_address
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as response:
                    if response.status != 200:
                        raise Exception(f"Failed to generate salt: HTTP {response.status}")
                    
                    data = await response.json()
            
            print("✅ API Response received!")
            print(f"   Target prefix: 0x{data['target_prefix']}")
            print(f"   Total attempts: {data['total_attempts']:,}")
            print(f"   Generation time: {data['timeMs']}ms")
            print(f"   Matches found: {data['matches_found']}")
            
            # Validate response
            if not data.get('has_target_prefix') or not data.get('results'):
                raise Exception("No valid salt generated by API")
            
            salt = data['results'][0]['salt']
            bytecode_hash = data['bytecode_hash']
            
            print(f"✅ Salt generated: {salt}")
            print(f"   Salt length: {len(salt)} chars")
            print(f"   Bytecode hash: {bytecode_hash}")
            
            # Validate salt format
            if not salt.startswith('0x') or len(salt) != 66:
                raise Exception(f"Invalid salt format: {salt}")
            
            # Test hex conversion
            try:
                salt_bytes = bytes.fromhex(salt[2:])
                print(f"✅ Salt hex conversion successful: {len(salt_bytes)} bytes")
            except ValueError as e:
                raise Exception(f"Salt hex conversion failed: {e}")
            
            return salt, bytecode_hash, data
            
        except Exception as e:
            print(f"❌ Salt generation failed: {e}")
            raise
    
    def calculate_create2_address(self, salt: str, bytecode_hash: str) -> str:
        """Calculate CREATE2 address"""
        try:
            print(f"🧮 Calculating CREATE2 address...")
            print(f"   Factory: {self.factory_address}")
            print(f"   Salt: {salt}")
            print(f"   Bytecode hash: {bytecode_hash}")
            
            # Remove 0x prefix for calculation
            factory = self.factory_address[2:] if self.factory_address.startswith('0x') else self.factory_address
            salt_clean = salt[2:] if salt.startswith('0x') else salt
            bytecode_clean = bytecode_hash[2:] if bytecode_hash.startswith('0x') else bytecode_hash
            
            print(f"   Cleaned factory: {factory}")
            print(f"   Cleaned salt: {salt_clean}")
            print(f"   Cleaned bytecode: {bytecode_clean}")
            
            # CREATE2 formula: keccak256(0xff + factory + salt + bytecode_hash)
            data = bytes.fromhex("ff" + factory + salt_clean + bytecode_clean)
            print(f"   Data for hash: ff{factory}{salt_clean}{bytecode_clean}")
            print(f"   Data length: {len(data)} bytes")
            
            hash_result = keccak.new(digest_bits=256)
            hash_result.update(data)
            hash_bytes = hash_result.digest()
            
            # Address = last 20 bytes
            address = "0x" + hash_bytes[-20:].hex()
            
            # Return checksum address
            checksum_address = to_checksum_address(address)
            
            print(f"✅ CREATE2 address calculated: {checksum_address}")
            
            return checksum_address
            
        except Exception as e:
            print(f"❌ CREATE2 calculation failed: {e}")
            raise
    
    def test_address_prefix(self, address: str, expected_prefix: str = "69") -> bool:
        """Test if address starts with expected prefix"""
        actual_prefix = address[2:4].lower()
        expected_prefix = expected_prefix.lower()
        
        if actual_prefix == expected_prefix:
            print(f"✅ Address prefix correct: 0x{actual_prefix}")
            return True
        else:
            print(f"❌ Address prefix mismatch: expected 0x{expected_prefix}, got 0x{actual_prefix}")
            return False
    
    def simulate_salt_conversion(self, salt: str):
        """Simulate how the salt will be converted for the smart contract"""
        print(f"🔧 Testing salt conversion for smart contract...")
        
        try:
            # This is what our deployer does
            if salt.startswith('0x'):
                salt_bytes = bytes.fromhex(salt[2:])
            else:
                salt_bytes = bytes.fromhex(salt)
            
            print(f"✅ Salt conversion successful")
            print(f"   Original: {salt}")
            print(f"   Bytes: {salt_bytes.hex()}")
            print(f"   Length: {len(salt_bytes)} bytes")
            
            # Ensure it's exactly 32 bytes for bytes32
            if len(salt_bytes) != 32:
                print(f"⚠️  Warning: Salt is {len(salt_bytes)} bytes, not 32 bytes")
            
            return salt_bytes
            
        except Exception as e:
            print(f"❌ Salt conversion failed: {e}")
            raise
    
    async def run_full_test(self, token_name: str = "TestToken", token_symbol: str = "TEST"):
        """Run the complete vanity address test"""
        print("🚀 Starting 0x69 Vanity Address Test")
        print("=" * 60)
        
        try:
            # Step 1: Generate salt from API
            salt, bytecode_hash, api_data = await self.test_salt_generation(token_name, token_symbol)
            
            print("\n" + "=" * 60)
            
            # Step 2: Test salt conversion
            salt_bytes = self.simulate_salt_conversion(salt)
            
            print("\n" + "=" * 60)
            
            # Step 3: Calculate CREATE2 address
            predicted_address = self.calculate_create2_address(salt, bytecode_hash)
            
            print("\n" + "=" * 60)
            
            # Step 4: Validate address prefix
            is_valid_prefix = self.test_address_prefix(predicted_address, "69")
            
            print("\n" + "=" * 60)
            print("📊 TEST SUMMARY")
            print("=" * 60)
            print(f"Token: {token_name} ({token_symbol})")
            print(f"Salt: {salt}")
            print(f"Predicted Address: {predicted_address}")
            print(f"Address Prefix: 0x{predicted_address[2:4]}")
            print(f"Valid 0x69 Address: {'✅ YES' if is_valid_prefix else '❌ NO'}")
            print(f"API Generation Time: {api_data['timeMs']}ms")
            print(f"API Attempts: {api_data['total_attempts']:,}")
            
            if is_valid_prefix:
                print("\n🎉 SUCCESS! 0x69 vanity address generation is working!")
                print(f"📈 Ready for DexScreener: https://dexscreener.com/ethereum/{predicted_address}")
                print(f"🌐 Ready for Etherscan: https://etherscan.io/address/{predicted_address}")
            else:
                print("\n❌ FAILED! Address doesn't start with 0x69")
                
            return {
                'success': is_valid_prefix,
                'salt': salt,
                'predicted_address': predicted_address,
                'api_data': api_data
            }
            
        except Exception as e:
            print(f"\n❌ TEST FAILED: {e}")
            return {'success': False, 'error': str(e)}

async def main():
    """Run multiple tests with different tokens"""
    tester = VanityAddressTest()
    
    test_cases = [
        ("TestCoin", "TEST"),
        ("DemoToken", "DEMO"), 
        ("VanityAddr", "VANITY")
    ]
    
    print("🧪 Running Multiple Vanity Address Tests")
    print("=" * 80)
    
    results = []
    
    for token_name, token_symbol in test_cases:
        print(f"\n🔬 TEST CASE: {token_name} ({token_symbol})")
        print("-" * 80)
        
        result = await tester.run_full_test(token_name, token_symbol)
        results.append({
            'token_name': token_name,
            'token_symbol': token_symbol,
            **result
        })
        
        print("\n" + "⏳ Waiting 2 seconds before next test...")
        await asyncio.sleep(2)
    
    # Summary of all tests
    print("\n" + "=" * 80)
    print("📋 ALL TESTS SUMMARY")
    print("=" * 80)
    
    successful_tests = 0
    for i, result in enumerate(results, 1):
        status = "✅ PASS" if result['success'] else "❌ FAIL"
        print(f"{i}. {result['token_name']} ({result['token_symbol']}): {status}")
        if result['success']:
            successful_tests += 1
            print(f"   Address: {result['predicted_address']}")
    
    print(f"\nSuccess Rate: {successful_tests}/{len(results)} ({successful_tests/len(results)*100:.1f}%)")
    
    if successful_tests == len(results):
        print("\n🎉 ALL TESTS PASSED! 0x69 vanity generation is working perfectly!")
        print("✅ Ready to implement in main deployer!")
    else:
        print(f"\n⚠️  Some tests failed. Need to investigate issues.")

if __name__ == "__main__":
    asyncio.run(main()) 